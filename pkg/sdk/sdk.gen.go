// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AppLog.
const (
	Kafka AppLog = "kafka"
	None  AppLog = "none"
)

// App defines model for app.
type App struct {
	// Binary Binary ID
	Binary int64 `json:"binary"`

	// Env Environment variables
	Env *map[string]string `json:"env,omitempty"`

	// Log Logging channel (by default - kafka, which allows exploring logs with API)
	Log *AppLog `json:"log"`

	// Name App name
	Name *string `json:"name,omitempty"`

	// Plan Plan name
	Plan string `json:"plan"`

	// RspHeaders Extra headers to add to the response
	RspHeaders *map[string]string `json:"rsp_headers,omitempty"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status int `json:"status"`

	// Url App URL
	Url *string `json:"url,omitempty"`
}

// AppLog Logging channel (by default - kafka, which allows exploring logs with API)
type AppLog string

// AppShort defines model for app_short.
type AppShort struct {
	// Id App ID
	Id int64 `json:"id"`

	// Name App name
	Name string `json:"name"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status int `json:"status"`

	// Url App URL
	Url string `json:"url"`
}

// Binary defines model for binary.
type Binary struct {
	// Errors Compilation errors
	Errors *string `json:"errors,omitempty"`

	// Status Status code:<br>0 - pending<br>1 - compiled<br>2 - compilation failed (errors available)<br>3 - compilation failed (errors not available)<br>4 - resulting binary exceeded the limit<br>5 - unsupported source language
	Status int `json:"status"`

	// Type Type
	Type int `json:"type"`
}

// BinaryShort defines model for binary_short.
type BinaryShort struct {
	// Id Binary ID
	Id int64 `json:"id"`

	// Status Status code:<br>0 - pending<br>1 - compiled<br>2 - compilation failed (errors available)<br>3 - compilation failed (errors not available)<br>4 - resulting binary exceeded the limit<br>5 - unsupported source language
	Status int `json:"status"`

	// UnrefSince Not used since (UTC)
	UnrefSince *string `json:"unref_since,omitempty"`
}

// CallStats Edge app call statistics
type CallStats struct {
	// CountByStatus Count by status
	CountByStatus []CountByStatus `json:"count_by_status"`

	// Time Beginning ot reporting slot
	Time time.Time `json:"time"`
}

// Client defines model for client.
type Client struct {
	// AppCount Actual allowed number of apps
	AppCount int `json:"app_count"`

	// AppLimit Max allowed number of apps
	AppLimit int `json:"app_limit"`

	// DailyConsumption Actual number of calls for all apps during the current day (UTC)
	DailyConsumption int `json:"daily_consumption"`

	// DailyLimit Max allowed calls for all apps during a day (UTC)
	DailyLimit int `json:"daily_limit"`

	// HourlyConsumption Actual number of calls for all apps during the current hour
	HourlyConsumption int `json:"hourly_consumption"`

	// HourlyLimit Max allowed calls for all apps during an hour
	HourlyLimit int `json:"hourly_limit"`

	// Status Status code:<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status int `json:"status"`
}

// CountByStatus defines model for count_by_status.
type CountByStatus struct {
	// Count Number of app calls
	Count int `json:"count"`

	// Status HTTP status
	Status int `json:"status"`
}

// DurationStats Edge app execution duration statistics
type DurationStats struct {
	// Avg Average duration in usec
	Avg int64 `json:"avg"`

	// Max Max duration in usec
	Max int64 `json:"max"`

	// Median Median (50% percentile) duration in usec
	Median int64 `json:"median"`

	// Min Min duration in usec
	Min int64 `json:"min"`

	// Perc75 75% percentile duration in usec
	Perc75 int64 `json:"perc75"`

	// Perc90 90% percentile duration in usec
	Perc90 int64 `json:"perc90"`

	// Time Beginning ot reporting slot
	Time time.Time `json:"time"`
}

// Plan defines model for plan.
type Plan struct {
	// MaxDuration Max duration in 10 ms ticks
	MaxDuration int `json:"max_duration"`

	// MaxSubrequests Max number of external network requests (0 means disabled)
	MaxSubrequests int `json:"max_subrequests"`

	// MemLimit Max memory in bytes
	MemLimit int `json:"mem_limit"`
}

// CompileJavaScriptMultipartBody defines parameters for CompileJavaScript.
type CompileJavaScriptMultipartBody struct {
	PackageJson *openapi_types.File `json:"package_json,omitempty"`
	Source      *openapi_types.File `json:"source,omitempty"`
}

// CompileRustMultipartBody defines parameters for CompileRust.
type CompileRustMultipartBody struct {
	Source *openapi_types.File `json:"source,omitempty"`
	Toml   *openapi_types.File `json:"toml,omitempty"`
}

// AppCallsParams defines parameters for AppCalls.
type AppCallsParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// AppDurationParams defines parameters for AppDuration.
type AppDurationParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// TotalCallsParams defines parameters for TotalCalls.
type TotalCallsParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// AddAppJSONRequestBody defines body for AddApp for application/json ContentType.
type AddAppJSONRequestBody = App

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody = App

// CompileJavaScriptMultipartRequestBody defines body for CompileJavaScript for multipart/form-data ContentType.
type CompileJavaScriptMultipartRequestBody CompileJavaScriptMultipartBody

// CompileRustMultipartRequestBody defines body for CompileRust for multipart/form-data ContentType.
type CompileRustMultipartRequestBody CompileRustMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// ClientSDK which conforms to the OpenAPI3 specification for this service.
type ClientSDK struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*ClientSDK) error

// Creates a new ClientSDK, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*ClientSDK, error) {
	// create a client with sane default values
	client := ClientSDK{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *ClientSDK) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *ClientSDK) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApps request
	ListApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAppWithBody request with any body
	AddAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddApp(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelApp request
	DelApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBinaries request
	ListBinaries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompileJavaScriptWithBody request with any body
	CompileJavaScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBinaryWithBody request with any body
	StoreBinaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompileRustWithBody request with any body
	CompileRustWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelBinary request
	DelBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinary request
	GetBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientMe request
	GetClientMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlan request
	GetPlan(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppCalls request
	AppCalls(ctx context.Context, id int, params *AppCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppDuration request
	AppDuration(ctx context.Context, id int, params *AppDurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TotalCalls request
	TotalCalls(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *ClientSDK) ListApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddApp(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateApp(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListBinaries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBinariesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) CompileJavaScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompileJavaScriptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) StoreBinaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBinaryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) CompileRustWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompileRustRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelBinaryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinaryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetPlan(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AppCalls(ctx context.Context, id int, params *AppCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCallsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AppDuration(ctx context.Context, id int, params *AppDurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppDurationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) TotalCalls(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTotalCallsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppRequest calls the generic AddApp builder with application/json body
func NewAddAppRequest(server string, body AddAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppRequestWithBody(server, "application/json", bodyReader)
}

// NewAddAppRequestWithBody generates requests for AddApp with any type of body
func NewAddAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelAppRequest generates requests for DelApp
func NewDelAppRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, id int64, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBinariesRequest generates requests for ListBinaries
func NewListBinariesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompileJavaScriptRequestWithBody generates requests for CompileJavaScript with any type of body
func NewCompileJavaScriptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/javascript")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStoreBinaryRequestWithBody generates requests for StoreBinary with any type of body
func NewStoreBinaryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompileRustRequestWithBody generates requests for CompileRust with any type of body
func NewCompileRustRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/rust")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelBinaryRequest generates requests for DelBinary
func NewDelBinaryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBinaryRequest generates requests for GetBinary
func NewGetBinaryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientMeRequest generates requests for GetClientMe
func NewGetClientMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlanRequest generates requests for GetPlan
func NewGetPlanRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCallsRequest generates requests for AppCalls
func NewAppCallsRequest(server string, id int, params *AppCallsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/app_calls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppDurationRequest generates requests for AppDuration
func NewAppDurationRequest(server string, id int, params *AppDurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/app_duration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTotalCallsRequest generates requests for TotalCalls
func NewTotalCallsRequest(server string, params *TotalCallsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/total_calls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *ClientSDK) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *ClientSDK) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// AddAppWithBodyWithResponse request with any body
	AddAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResponse, error)

	AddAppWithResponse(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResponse, error)

	// DelAppWithResponse request
	DelAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// ListBinariesWithResponse request
	ListBinariesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListBinariesResponse, error)

	// CompileJavaScriptWithBodyWithResponse request with any body
	CompileJavaScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileJavaScriptResponse, error)

	// StoreBinaryWithBodyWithResponse request with any body
	StoreBinaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBinaryResponse, error)

	// CompileRustWithBodyWithResponse request with any body
	CompileRustWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileRustResponse, error)

	// DelBinaryWithResponse request
	DelBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelBinaryResponse, error)

	// GetBinaryWithResponse request
	GetBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryResponse, error)

	// GetClientMeWithResponse request
	GetClientMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientMeResponse, error)

	// ListPlansWithResponse request
	ListPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// GetPlanWithResponse request
	GetPlanWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetPlanResponse, error)

	// AppCallsWithResponse request
	AppCallsWithResponse(ctx context.Context, id int, params *AppCallsParams, reqEditors ...RequestEditorFn) (*AppCallsResponse, error)

	// AppDurationWithResponse request
	AppDurationWithResponse(ctx context.Context, id int, params *AppDurationParams, reqEditors ...RequestEditorFn) (*AppDurationResponse, error)

	// TotalCallsWithResponse request
	TotalCallsWithResponse(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*TotalCallsResponse, error)
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AppShort
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
}

// Status returns HTTPResponse.Status
func (r AddAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBinariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BinaryShort
}

// Status returns HTTPResponse.Status
func (r ListBinariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBinariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompileJavaScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r CompileJavaScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompileJavaScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r StoreBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompileRustResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r CompileRustResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompileRustResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binary
}

// Status returns HTTPResponse.Status
func (r GetBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Client
}

// Status returns HTTPResponse.Status
func (r GetClientMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plan
}

// Status returns HTTPResponse.Status
func (r GetPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCallsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CallStats
}

// Status returns HTTPResponse.Status
func (r AppCallsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCallsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppDurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DurationStats
}

// Status returns HTTPResponse.Status
func (r AppDurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppDurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TotalCallsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CallStats
}

// Status returns HTTPResponse.Status
func (r TotalCallsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TotalCallsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// AddAppWithBodyWithResponse request with arbitrary body returning *AddAppResponse
func (c *ClientWithResponses) AddAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResponse, error) {
	rsp, err := c.AddAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResponse(rsp)
}

func (c *ClientWithResponses) AddAppWithResponse(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResponse, error) {
	rsp, err := c.AddApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResponse(rsp)
}

// DelAppWithResponse request returning *DelAppResponse
func (c *ClientWithResponses) DelAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelAppResponse, error) {
	rsp, err := c.DelApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// ListBinariesWithResponse request returning *ListBinariesResponse
func (c *ClientWithResponses) ListBinariesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListBinariesResponse, error) {
	rsp, err := c.ListBinaries(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBinariesResponse(rsp)
}

// CompileJavaScriptWithBodyWithResponse request with arbitrary body returning *CompileJavaScriptResponse
func (c *ClientWithResponses) CompileJavaScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileJavaScriptResponse, error) {
	rsp, err := c.CompileJavaScriptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompileJavaScriptResponse(rsp)
}

// StoreBinaryWithBodyWithResponse request with arbitrary body returning *StoreBinaryResponse
func (c *ClientWithResponses) StoreBinaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBinaryResponse, error) {
	rsp, err := c.StoreBinaryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBinaryResponse(rsp)
}

// CompileRustWithBodyWithResponse request with arbitrary body returning *CompileRustResponse
func (c *ClientWithResponses) CompileRustWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileRustResponse, error) {
	rsp, err := c.CompileRustWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompileRustResponse(rsp)
}

// DelBinaryWithResponse request returning *DelBinaryResponse
func (c *ClientWithResponses) DelBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelBinaryResponse, error) {
	rsp, err := c.DelBinary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelBinaryResponse(rsp)
}

// GetBinaryWithResponse request returning *GetBinaryResponse
func (c *ClientWithResponses) GetBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryResponse, error) {
	rsp, err := c.GetBinary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinaryResponse(rsp)
}

// GetClientMeWithResponse request returning *GetClientMeResponse
func (c *ClientWithResponses) GetClientMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientMeResponse, error) {
	rsp, err := c.GetClientMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientMeResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// GetPlanWithResponse request returning *GetPlanResponse
func (c *ClientWithResponses) GetPlanWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetPlanResponse, error) {
	rsp, err := c.GetPlan(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanResponse(rsp)
}

// AppCallsWithResponse request returning *AppCallsResponse
func (c *ClientWithResponses) AppCallsWithResponse(ctx context.Context, id int, params *AppCallsParams, reqEditors ...RequestEditorFn) (*AppCallsResponse, error) {
	rsp, err := c.AppCalls(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCallsResponse(rsp)
}

// AppDurationWithResponse request returning *AppDurationResponse
func (c *ClientWithResponses) AppDurationWithResponse(ctx context.Context, id int, params *AppDurationParams, reqEditors ...RequestEditorFn) (*AppDurationResponse, error) {
	rsp, err := c.AppDuration(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppDurationResponse(rsp)
}

// TotalCallsWithResponse request returning *TotalCallsResponse
func (c *ClientWithResponses) TotalCallsWithResponse(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*TotalCallsResponse, error) {
	rsp, err := c.TotalCalls(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTotalCallsResponse(rsp)
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAppResponse parses an HTTP response from a AddAppWithResponse call
func ParseAddAppResponse(rsp *http.Response) (*AddAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDelAppResponse parses an HTTP response from a DelAppWithResponse call
func ParseDelAppResponse(rsp *http.Response) (*DelAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBinariesResponse parses an HTTP response from a ListBinariesWithResponse call
func ParseListBinariesResponse(rsp *http.Response) (*ListBinariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBinariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BinaryShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompileJavaScriptResponse parses an HTTP response from a CompileJavaScriptWithResponse call
func ParseCompileJavaScriptResponse(rsp *http.Response) (*CompileJavaScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompileJavaScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreBinaryResponse parses an HTTP response from a StoreBinaryWithResponse call
func ParseStoreBinaryResponse(rsp *http.Response) (*StoreBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompileRustResponse parses an HTTP response from a CompileRustWithResponse call
func ParseCompileRustResponse(rsp *http.Response) (*CompileRustResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompileRustResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDelBinaryResponse parses an HTTP response from a DelBinaryWithResponse call
func ParseDelBinaryResponse(rsp *http.Response) (*DelBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBinaryResponse parses an HTTP response from a GetBinaryWithResponse call
func ParseGetBinaryResponse(rsp *http.Response) (*GetBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClientMeResponse parses an HTTP response from a GetClientMeWithResponse call
func ParseGetClientMeResponse(rsp *http.Response) (*GetClientMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Client
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlanResponse parses an HTTP response from a GetPlanWithResponse call
func ParseGetPlanResponse(rsp *http.Response) (*GetPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppCallsResponse parses an HTTP response from a AppCallsWithResponse call
func ParseAppCallsResponse(rsp *http.Response) (*AppCallsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppCallsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CallStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppDurationResponse parses an HTTP response from a AppDurationWithResponse call
func ParseAppDurationResponse(rsp *http.Response) (*AppDurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppDurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DurationStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTotalCallsResponse parses an HTTP response from a TotalCallsWithResponse call
func ParseTotalCallsResponse(rsp *http.Response) (*TotalCallsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TotalCallsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CallStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
