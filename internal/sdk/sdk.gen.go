// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AppLog.
const (
	AppLogKafka AppLog = "kafka"
	AppLogNone  AppLog = "none"
)

// Defines values for UpdateAppJSONBodyLog.
const (
	UpdateAppJSONBodyLogKafka UpdateAppJSONBodyLog = "kafka"
	UpdateAppJSONBodyLogNone  UpdateAppJSONBodyLog = "none"
)

// App defines model for app.
type App struct {
	// Binary Binary ID
	Binary *int64 `json:"binary,omitempty"`

	// Env Environment variables
	Env *map[string]string `json:"env,omitempty"`

	// Log Logging channel (by default - kafka, which allows exploring logs with API)
	Log *AppLog `json:"log"`

	// Name App name
	Name *string `json:"name,omitempty"`

	// Plan Plan name
	Plan *string `json:"plan,omitempty"`

	// RspHeaders Extra headers to add to the response
	RspHeaders *map[string]string `json:"rsp_headers,omitempty"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status *int `json:"status,omitempty"`

	// Url App URL
	Url *string `json:"url,omitempty"`
}

// AppLog Logging channel (by default - kafka, which allows exploring logs with API)
type AppLog string

// AppShort defines model for app_short.
type AppShort struct {
	// Id App ID
	Id int64 `json:"id"`

	// Name App name
	Name string `json:"name"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status int `json:"status"`

	// Url App URL
	Url string `json:"url"`
}

// Binary defines model for binary.
type Binary struct {
	// Errors Compilation errors
	Errors *string `json:"errors,omitempty"`

	// Status Status code:<br>0 - pending<br>1 - compiled<br>2 - compilation failed (errors available)<br>3 - compilation failed (errors not available)<br>4 - resulting binary exceeded the limit<br>5 - unsupported source language
	Status int `json:"status"`

	// Type Type
	Type int `json:"type"`

	// UnrefSince Not used since (UTC)
	UnrefSince *string `json:"unref_since,omitempty"`
}

// BinaryShort defines model for binary_short.
type BinaryShort struct {
	// Id Binary ID
	Id int64 `json:"id"`

	// Status Status code:<br>0 - pending<br>1 - compiled<br>2 - compilation failed (errors available)<br>3 - compilation failed (errors not available)<br>4 - resulting binary exceeded the limit<br>5 - unsupported source language
	Status int `json:"status"`

	// UnrefSince Not used since (UTC)
	UnrefSince *string `json:"unref_since,omitempty"`
}

// CallStats Edge app call statistics
type CallStats struct {
	// CountByStatus Count by status
	CountByStatus []CountByStatus `json:"count_by_status"`

	// Time Beginning ot reporting slot
	Time time.Time `json:"time"`
}

// Client defines model for client.
type Client struct {
	// AppCount Actual allowed number of apps
	AppCount int `json:"app_count"`

	// AppLimit Max allowed number of apps
	AppLimit int `json:"app_limit"`

	// DailyConsumption Actual number of calls for all apps during the current day (UTC)
	DailyConsumption int `json:"daily_consumption"`

	// DailyLimit Max allowed calls for all apps during a day (UTC)
	DailyLimit int `json:"daily_limit"`

	// HourlyConsumption Actual number of calls for all apps during the current hour
	HourlyConsumption int `json:"hourly_consumption"`

	// HourlyLimit Max allowed calls for all apps during an hour
	HourlyLimit int `json:"hourly_limit"`

	// Status Status code:<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status int `json:"status"`
}

// CountByStatus defines model for count_by_status.
type CountByStatus struct {
	// Count Number of app calls
	Count int `json:"count"`

	// Status HTTP status
	Status int `json:"status"`
}

// DurationStats Edge app execution duration statistics
type DurationStats struct {
	// Avg Average duration in usec
	Avg int64 `json:"avg"`

	// Max Max duration in usec
	Max int64 `json:"max"`

	// Median Median (50% percentile) duration in usec
	Median int64 `json:"median"`

	// Min Min duration in usec
	Min int64 `json:"min"`

	// Perc75 75% percentile duration in usec
	Perc75 int64 `json:"perc75"`

	// Perc90 90% percentile duration in usec
	Perc90 int64 `json:"perc90"`

	// Time Beginning ot reporting slot
	Time time.Time `json:"time"`
}

// Plan defines model for plan.
type Plan struct {
	// MaxDuration Max duration in msec
	MaxDuration int `json:"max_duration"`

	// MaxSubrequests Max number of external network requests (0 means disabled)
	MaxSubrequests int `json:"max_subrequests"`

	// MemLimit Max memory in bytes
	MemLimit int `json:"mem_limit"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	// Binary Binary ID
	Binary int64 `json:"binary"`

	// Env Environment variables
	Env *map[string]string `json:"env,omitempty"`

	// Log Logging channel (by default - kafka, which allows exploring logs with API)
	Log *UpdateAppJSONBodyLog `json:"log"`

	// Name App name
	Name *string `json:"name,omitempty"`

	// Plan Plan name
	Plan string `json:"plan"`

	// RspHeaders Extra headers to add to the response
	RspHeaders *map[string]string `json:"rsp_headers,omitempty"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3/4 - hourly/daily call limit exceeded)
	Status int `json:"status"`

	// Url App URL
	Url *string `json:"url,omitempty"`
}

// UpdateAppJSONBodyLog defines parameters for UpdateApp.
type UpdateAppJSONBodyLog string

// CompileJavaScriptMultipartBody defines parameters for CompileJavaScript.
type CompileJavaScriptMultipartBody struct {
	PackageJson *openapi_types.File `json:"package_json,omitempty"`
	Source      *openapi_types.File `json:"source,omitempty"`
}

// CompileRustMultipartBody defines parameters for CompileRust.
type CompileRustMultipartBody struct {
	Source *openapi_types.File `json:"source,omitempty"`
	Toml   *openapi_types.File `json:"toml,omitempty"`
}

// AppCallsParams defines parameters for AppCalls.
type AppCallsParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// AppDurationParams defines parameters for AppDuration.
type AppDurationParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// TotalCallsParams defines parameters for TotalCalls.
type TotalCallsParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// AddAppJSONRequestBody defines body for AddApp for application/json ContentType.
type AddAppJSONRequestBody = App

// PatchAppJSONRequestBody defines body for PatchApp for application/json ContentType.
type PatchAppJSONRequestBody = App

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// CompileJavaScriptMultipartRequestBody defines body for CompileJavaScript for multipart/form-data ContentType.
type CompileJavaScriptMultipartRequestBody CompileJavaScriptMultipartBody

// CompileRustMultipartRequestBody defines body for CompileRust for multipart/form-data ContentType.
type CompileRustMultipartRequestBody CompileRustMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// ClientSDK which conforms to the OpenAPI3 specification for this service.
type ClientSDK struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*ClientSDK) error

// Creates a new ClientSDK, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*ClientSDK, error) {
	// create a client with sane default values
	client := ClientSDK{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *ClientSDK) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *ClientSDK) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApps request
	ListApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAppWithBody request with any body
	AddAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddApp(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelApp request
	DelApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppWithBody request with any body
	PatchAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApp(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBinaries request
	ListBinaries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompileJavaScriptWithBody request with any body
	CompileJavaScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBinaryWithBody request with any body
	StoreBinaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompileRustWithBody request with any body
	CompileRustWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelBinary request
	DelBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinary request
	GetBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientMe request
	GetClientMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlan request
	GetPlan(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppCalls request
	AppCalls(ctx context.Context, id int64, params *AppCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppDuration request
	AppDuration(ctx context.Context, id int64, params *AppDurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TotalCalls request
	TotalCalls(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *ClientSDK) ListApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddApp(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PatchAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PatchApp(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateApp(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListBinaries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBinariesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) CompileJavaScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompileJavaScriptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) StoreBinaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBinaryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) CompileRustWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompileRustRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelBinaryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinaryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetPlan(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AppCalls(ctx context.Context, id int64, params *AppCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppCallsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AppDuration(ctx context.Context, id int64, params *AppDurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppDurationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) TotalCalls(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTotalCallsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppRequest calls the generic AddApp builder with application/json body
func NewAddAppRequest(server string, body AddAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppRequestWithBody(server, "application/json", bodyReader)
}

// NewAddAppRequestWithBody generates requests for AddApp with any type of body
func NewAddAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelAppRequest generates requests for DelApp
func NewDelAppRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppRequest calls the generic PatchApp builder with application/json body
func NewPatchAppRequest(server string, id int64, body PatchAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAppRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchAppRequestWithBody generates requests for PatchApp with any type of body
func NewPatchAppRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, id int64, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBinariesRequest generates requests for ListBinaries
func NewListBinariesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompileJavaScriptRequestWithBody generates requests for CompileJavaScript with any type of body
func NewCompileJavaScriptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/javascript")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStoreBinaryRequestWithBody generates requests for StoreBinary with any type of body
func NewStoreBinaryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompileRustRequestWithBody generates requests for CompileRust with any type of body
func NewCompileRustRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/rust")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelBinaryRequest generates requests for DelBinary
func NewDelBinaryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBinaryRequest generates requests for GetBinary
func NewGetBinaryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientMeRequest generates requests for GetClientMe
func NewGetClientMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlanRequest generates requests for GetPlan
func NewGetPlanRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCallsRequest generates requests for AppCalls
func NewAppCallsRequest(server string, id int64, params *AppCallsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/app_calls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppDurationRequest generates requests for AppDuration
func NewAppDurationRequest(server string, id int64, params *AppDurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/app_duration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTotalCallsRequest generates requests for TotalCalls
func NewTotalCallsRequest(server string, params *TotalCallsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/total_calls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *ClientSDK) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *ClientSDK) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// AddAppWithBodyWithResponse request with any body
	AddAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResponse, error)

	AddAppWithResponse(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResponse, error)

	// DelAppWithResponse request
	DelAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// PatchAppWithBodyWithResponse request with any body
	PatchAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppResponse, error)

	PatchAppWithResponse(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAppResponse, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// ListBinariesWithResponse request
	ListBinariesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListBinariesResponse, error)

	// CompileJavaScriptWithBodyWithResponse request with any body
	CompileJavaScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileJavaScriptResponse, error)

	// StoreBinaryWithBodyWithResponse request with any body
	StoreBinaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBinaryResponse, error)

	// CompileRustWithBodyWithResponse request with any body
	CompileRustWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileRustResponse, error)

	// DelBinaryWithResponse request
	DelBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelBinaryResponse, error)

	// GetBinaryWithResponse request
	GetBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryResponse, error)

	// GetClientMeWithResponse request
	GetClientMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientMeResponse, error)

	// ListPlansWithResponse request
	ListPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// GetPlanWithResponse request
	GetPlanWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetPlanResponse, error)

	// AppCallsWithResponse request
	AppCallsWithResponse(ctx context.Context, id int64, params *AppCallsParams, reqEditors ...RequestEditorFn) (*AppCallsResponse, error)

	// AppDurationWithResponse request
	AppDurationWithResponse(ctx context.Context, id int64, params *AppDurationParams, reqEditors ...RequestEditorFn) (*AppDurationResponse, error)

	// TotalCallsWithResponse request
	TotalCallsWithResponse(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*TotalCallsResponse, error)
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AppShort
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
}

// Status returns HTTPResponse.Status
func (r AddAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
}

// Status returns HTTPResponse.Status
func (r PatchAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBinariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BinaryShort
}

// Status returns HTTPResponse.Status
func (r ListBinariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBinariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompileJavaScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r CompileJavaScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompileJavaScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r StoreBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompileRustResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r CompileRustResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompileRustResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binary
}

// Status returns HTTPResponse.Status
func (r GetBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Client
}

// Status returns HTTPResponse.Status
func (r GetClientMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plan
}

// Status returns HTTPResponse.Status
func (r GetPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCallsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CallStats
}

// Status returns HTTPResponse.Status
func (r AppCallsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCallsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppDurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DurationStats
}

// Status returns HTTPResponse.Status
func (r AppDurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppDurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TotalCallsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CallStats
}

// Status returns HTTPResponse.Status
func (r TotalCallsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TotalCallsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// AddAppWithBodyWithResponse request with arbitrary body returning *AddAppResponse
func (c *ClientWithResponses) AddAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResponse, error) {
	rsp, err := c.AddAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResponse(rsp)
}

func (c *ClientWithResponses) AddAppWithResponse(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResponse, error) {
	rsp, err := c.AddApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResponse(rsp)
}

// DelAppWithResponse request returning *DelAppResponse
func (c *ClientWithResponses) DelAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelAppResponse, error) {
	rsp, err := c.DelApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// PatchAppWithBodyWithResponse request with arbitrary body returning *PatchAppResponse
func (c *ClientWithResponses) PatchAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppResponse, error) {
	rsp, err := c.PatchAppWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppResponse(rsp)
}

func (c *ClientWithResponses) PatchAppWithResponse(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAppResponse, error) {
	rsp, err := c.PatchApp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// ListBinariesWithResponse request returning *ListBinariesResponse
func (c *ClientWithResponses) ListBinariesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListBinariesResponse, error) {
	rsp, err := c.ListBinaries(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBinariesResponse(rsp)
}

// CompileJavaScriptWithBodyWithResponse request with arbitrary body returning *CompileJavaScriptResponse
func (c *ClientWithResponses) CompileJavaScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileJavaScriptResponse, error) {
	rsp, err := c.CompileJavaScriptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompileJavaScriptResponse(rsp)
}

// StoreBinaryWithBodyWithResponse request with arbitrary body returning *StoreBinaryResponse
func (c *ClientWithResponses) StoreBinaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBinaryResponse, error) {
	rsp, err := c.StoreBinaryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBinaryResponse(rsp)
}

// CompileRustWithBodyWithResponse request with arbitrary body returning *CompileRustResponse
func (c *ClientWithResponses) CompileRustWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileRustResponse, error) {
	rsp, err := c.CompileRustWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompileRustResponse(rsp)
}

// DelBinaryWithResponse request returning *DelBinaryResponse
func (c *ClientWithResponses) DelBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelBinaryResponse, error) {
	rsp, err := c.DelBinary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelBinaryResponse(rsp)
}

// GetBinaryWithResponse request returning *GetBinaryResponse
func (c *ClientWithResponses) GetBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryResponse, error) {
	rsp, err := c.GetBinary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinaryResponse(rsp)
}

// GetClientMeWithResponse request returning *GetClientMeResponse
func (c *ClientWithResponses) GetClientMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientMeResponse, error) {
	rsp, err := c.GetClientMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientMeResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// GetPlanWithResponse request returning *GetPlanResponse
func (c *ClientWithResponses) GetPlanWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetPlanResponse, error) {
	rsp, err := c.GetPlan(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanResponse(rsp)
}

// AppCallsWithResponse request returning *AppCallsResponse
func (c *ClientWithResponses) AppCallsWithResponse(ctx context.Context, id int64, params *AppCallsParams, reqEditors ...RequestEditorFn) (*AppCallsResponse, error) {
	rsp, err := c.AppCalls(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppCallsResponse(rsp)
}

// AppDurationWithResponse request returning *AppDurationResponse
func (c *ClientWithResponses) AppDurationWithResponse(ctx context.Context, id int64, params *AppDurationParams, reqEditors ...RequestEditorFn) (*AppDurationResponse, error) {
	rsp, err := c.AppDuration(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppDurationResponse(rsp)
}

// TotalCallsWithResponse request returning *TotalCallsResponse
func (c *ClientWithResponses) TotalCallsWithResponse(ctx context.Context, params *TotalCallsParams, reqEditors ...RequestEditorFn) (*TotalCallsResponse, error) {
	rsp, err := c.TotalCalls(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTotalCallsResponse(rsp)
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAppResponse parses an HTTP response from a AddAppWithResponse call
func ParseAddAppResponse(rsp *http.Response) (*AddAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDelAppResponse parses an HTTP response from a DelAppWithResponse call
func ParseDelAppResponse(rsp *http.Response) (*DelAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchAppResponse parses an HTTP response from a PatchAppWithResponse call
func ParsePatchAppResponse(rsp *http.Response) (*PatchAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBinariesResponse parses an HTTP response from a ListBinariesWithResponse call
func ParseListBinariesResponse(rsp *http.Response) (*ListBinariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBinariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BinaryShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompileJavaScriptResponse parses an HTTP response from a CompileJavaScriptWithResponse call
func ParseCompileJavaScriptResponse(rsp *http.Response) (*CompileJavaScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompileJavaScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreBinaryResponse parses an HTTP response from a StoreBinaryWithResponse call
func ParseStoreBinaryResponse(rsp *http.Response) (*StoreBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompileRustResponse parses an HTTP response from a CompileRustWithResponse call
func ParseCompileRustResponse(rsp *http.Response) (*CompileRustResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompileRustResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDelBinaryResponse parses an HTTP response from a DelBinaryWithResponse call
func ParseDelBinaryResponse(rsp *http.Response) (*DelBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBinaryResponse parses an HTTP response from a GetBinaryWithResponse call
func ParseGetBinaryResponse(rsp *http.Response) (*GetBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClientMeResponse parses an HTTP response from a GetClientMeWithResponse call
func ParseGetClientMeResponse(rsp *http.Response) (*GetClientMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Client
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlanResponse parses an HTTP response from a GetPlanWithResponse call
func ParseGetPlanResponse(rsp *http.Response) (*GetPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppCallsResponse parses an HTTP response from a AppCallsWithResponse call
func ParseAppCallsResponse(rsp *http.Response) (*AppCallsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppCallsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CallStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppDurationResponse parses an HTTP response from a AppDurationWithResponse call
func ParseAppDurationResponse(rsp *http.Response) (*AppDurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppDurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DurationStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTotalCallsResponse parses an HTTP response from a TotalCallsWithResponse call
func ParseTotalCallsResponse(rsp *http.Response) (*TotalCallsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TotalCallsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CallStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"NwAA//+BN2QDFUkAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
